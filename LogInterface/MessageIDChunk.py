import importlib
from enum import Enum
from pathlib import Path
from typing import Dict, List, Type

from StreamUtils import *
from Utils import sanitizeCName

from .Chunk import Chunk, ChunkEnum


class MessageIDChunk(Chunk):
    def __init__(self, parent):
        super().__init__(parent)

        self.logIDNames: Dict  # Maps log ID names to their values
        self.mapNameToID: Dict  # Maps names to IDs for messages
        self.mapLogToID: Dict  # Maps log IDs to their corresponding message IDs
        self.mapIDToLog: Dict  # Maps message IDs back to log IDs

        #cache
        self._MessageID_cached: Type[Enum]

    def eval(self, sutil: StreamUtil, offset: int = 0):
        startPos = sutil.tell()

        chunkMagicBit = sutil.readUChar()
        if chunkMagicBit != ChunkEnum.MessageIDsChunk.value:
            raise Exception(
                f"Expect magic number {ChunkEnum.MessageIDsChunk.value}, but get:{chunkMagicBit}"
            )

        logIDNames_size = sutil.readUChar()
        self.logIDNames = {}
        for id in range(logIDNames_size):
            self.logIDNames[id] = sutil.readStr()

        self.dumpMessageID()       

        self.mapNameToID = {mid.name: mid.value for mid in self.MessageID}
        self.mapNameToID["idProcessBegin"] = self.MessageID.idFrameBegin.value # type: ignore
        self.mapNameToID["idProcessFinished"] = self.MessageID.idFrameFinished.value # type: ignore
        self.mapLogToID = {}
        self.mapIDToLog = {}

        for id in range(logIDNames_size):
            if self.logIDNames[id] in self.mapNameToID:
                self.mapLogToID[id] = self.mapNameToID[self.logIDNames[id]]
                self.mapIDToLog[self.mapNameToID[self.logIDNames[id]]] = id
            else:
                self.mapLogToID[id] = self.MessageID.undefined.value # type: ignore

        self._children = []  # This chunk has no children

        self._startByte = offset
        self._endByte = sutil.tell() - startPos + offset

    def asDict(self):
        return {
            "logIDNames": self.logIDNames,
            "mapNameToID": self.mapNameToID,
            "mapLogToID": self.mapLogToID,
            "mapIDToLog": self.mapIDToLog,
        }

    @property
    def providedAttributes(self) -> List[str]:
        return ["logIdNames", "mapNameToID", "mapLogToID", "mapIDToLog"]

    def dumpMessageID(self):
        codeLines = []
        codeLines.append(
            '"""This file is generated by LogInterface/MessageIDChunk.dumpMessageID() to utilize multiprocessing, DO NOT EDIT!"""'
        )
        codeLines.append(f'"""Generated from log file: {self.logFilePath}"""')
        codeLines.append("from enum import Enum, auto")
        codeLines.append(f"class MessageID(Enum):")

        logIDNames_size = len(self.logIDNames)
        for id, name in self.logIDNames.items():
            codeLines.append(f"\t{sanitizeCName(name)} = {id}")
        codeLines.append(f"\tnumofMessageIDs = auto()")
        messageIDString = "\n".join(codeLines)
        with open(Path(__file__).parent / "LogClasses" / "MessageID.py", "w") as f:
            f.write(messageIDString)

    @property
    def MessageID(self) -> Type[Enum]:
        if hasattr(self, "_MessageID_cached") and self._MessageID_cached is not None:
            return self._MessageID_cached
        self._MessageID_cached = getattr(
            importlib.import_module(".LogClasses.MessageID", "LogInterface"), "MessageID"
        )
        return self._MessageID_cached


# with open("rb5.log", "rb") as f:
#     MyStream = io.BytesIO(f.read())
#     sutil = StreamUtil(MyStream)
#     sutil.read(1)
#     SettingsChunk = SettingsChunk(None)
#     SettingsChunk.eval(sutil)
#     print(vars(SettingsChunk))
#     sutil.read(1)
#     messageIDChunk=MessageIDChunk(None)
#     messageIDChunk.eval(sutil)
#     print(vars(messageIDChunk))
